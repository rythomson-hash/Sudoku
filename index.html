<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sudoku Player (standalone)</title>
<style>
  body{font-family:system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial;color:#111;margin:12px;}
  h1{font-size:18px;margin:6px 0 12px;}
  #controls{display:flex;gap:8px;flex-wrap:wrap;margin-bottom:10px;}
  button,input,textarea{font-size:15px;padding:8px;border-radius:8px;border:1px solid #ccc;background:#fff;}
  textarea{width:100%;height:90px;resize:vertical;}
  .board{display:grid;grid-template-columns:repeat(9,1fr);gap:1px;width:100%;max-width:520px;background:#222;border:6px solid #222;}
  .cell{aspect-ratio:1/1;display:flex;align-items:center;justify-content:center;background:#fff;font-size:20px;}
  .cell input{width:100%;height:100%;border:0;text-align:center;font-size:20px;outline:none;background:transparent;}
  /* thick box borders */
  .cell:nth-child(3n){border-right:3px solid #222;}
  .cell:nth-child(n+19):nth-child(-n+27){} /* just to keep CSS simple */
  .row-break{}
  .cell[data-clue="1"] input{font-weight:700;color:#000;}
  .footer{margin-top:12px;color:#555;font-size:13px;}
  .controls-right{margin-left:auto;}
  @media (max-width:520px){ .board{max-width:calc(100vw - 24px);} }
</style>
</head>
<body>
<h1>Sudoku Player — paste your puzzle and play on phone</h1>

<div id="controls">
  <textarea id="raw" placeholder="Paste the .sdk or raw puzzle here — keep the 9 rows or paste an 81-char string with digits and dots (use . for blank)."></textarea>
  <div style="display:flex;flex-direction:column;gap:8px;">
    <button id="parseBtn">Parse & Load</button>
    <button id="clearBtn">Clear</button>
    <button id="solveBtn">Auto-solve</button>
    <button id="checkBtn">Check</button>
    <button id="exportBtn">Export as .sdk</button>
  </div>
</div>

<div class="board" id="board"></div>

<div class="footer">
  Tips: If parsing fails, edit the pasted text so each of the 9 puzzle rows is on its own line, using digits 1‑9 and '.' for blanks. You can also paste a single 81-character string (left-to-right, top-to-bottom). After loading, tap cells to enter digits. Use "Auto-solve" to fill the solution (for learning/debugging).
</div>

<script>
// create grid elements
const board = document.getElementById('board');
let cells = []; // 81 inputs
for(let r=0;r<9;r++){
  for(let c=0;c<9;c++){
    const cell = document.createElement('div');
    cell.className = 'cell';
    cell.dataset.r = r; cell.dataset.c = c;
    const inp = document.createElement('input');
    inp.type = 'tel';
    inp.inputMode = 'numeric';
    inp.maxLength = 1;
    inp.addEventListener('input', onInput);
    inp.addEventListener('keydown', onKeyDown);
    cell.appendChild(inp);
    board.appendChild(cell);
    cells.push({div:cell,input:inp});
  }
}
function onInput(e){
  const v = e.target.value.replace(/[^1-9]/g,'');
  e.target.value = v;
}
function onKeyDown(e){
  const k = e.key;
  if(k==='Backspace' || k==='Delete'){ e.target.value=''; }
  if(/^[1-9]$/.test(k)){ e.target.value=k; e.preventDefault(); }
}

// helpers to get/set grid
function getGrid(){
  const g = Array.from({length:9},()=>Array(9).fill(0));
  for(let i=0;i<81;i++){
    const r = Math.floor(i/9), c = i%9;
    const v = cells[i].input.value.trim();
    g[r][c] = v===''?0:parseInt(v,10);
  }
  return g;
}
function setGrid(g,clues=false){
  for(let r=0;r<9;r++) for(let c=0;c<9;c++){
    const i = r*9+c;
    const v = (g[r] && g[r][c])?String(g[r][c]):'';
    cells[i].input.value = v;
    cells[i].div.dataset.clue = clues && v ? 1 : 0;
    cells[i].input.readOnly = (clues && v)? true : false;
  }
}

// parse function: accepts .sdk-like content, 9 lines, or 81-char string
function parseText(txt){
  // split lines, remove comments starting with #
  const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(s=>s && !s.startsWith('#'));
  // if there's exactly 9 useful lines, try to parse each
  if(lines.length>=9){
    const rows = lines.slice(0,9).map(l => {
      // keep digits and dots only; also allow other separators
      const filtered = l.replace(/[^0-9.]/g, '.');
      // now expand: take digits as cells, dots as blanks. If filtered has fewer than 9 chars,
      // attempt to interpret original line by extracting digits and using dots for non-digits.
      let cellsArr = [];
      for(let ch of filtered){
        if(ch === '.') cellsArr.push(0);
        else cellsArr.push(parseInt(ch,10));
        if(cellsArr.length===9) break;
      }
      // if still not 9, extract digits from original and fill rest with blanks
      if(cellsArr.length<9){
        const digits = Array.from(l.matchAll(/[1-9]/g)).map(m=>parseInt(m[0],10));
        // merge digits into leftmost positions, fill with zeros
        const merged = [];
        for(let i=0;i<9;i++){
          merged.push(i < digits.length ? digits[i] : 0);
        }
        return merged;
      }
      return cellsArr;
    });
    return rows;
  }
  // else try to find an 81-char string of digits/dots inside the text
  const compact = txt.replace(/[^0-9.]/g,'');
  if(compact.length>=81){
    const first81 = compact.slice(0,81);
    const rows=[];
    for(let r=0;r<9;r++){
      const row = first81.slice(r*9,(r+1)*9).split('').map(ch=> ch==='.'?0:parseInt(ch,10));
      rows.push(row);
    }
    return rows;
  }
  // fallback: cannot parse
  return null;
}

document.getElementById('parseBtn').addEventListener('click', ()=>{
  const raw = document.getElementById('raw').value;
  const grid = parseText(raw);
  if(!grid){ alert('Could not parse puzzle automatically. Please format as 9 lines with digits and dots, or paste an 81-character string.'); return; }
  setGrid(grid,true);
});

document.getElementById('clearBtn').addEventListener('click', ()=>{
  setGrid(Array.from({length:9},()=>Array(9).fill(0)),false);
  // also clear raw text
  // document.getElementById('raw').value='';
});

document.getElementById('checkBtn').addEventListener('click', ()=>{
  const g = getGrid();
  const errs = findConflicts(g);
  if(errs.length===0) alert('No obvious row/col/box conflicts detected.');
  else alert('Conflicts found at cells: ' + errs.map(x=>`(${x.r+1},${x.c+1})`).join(', '));
});

document.getElementById('exportBtn').addEventListener('click', ()=>{
  const g = getGrid();
  // build simple .sdk-like text with two header lines
  let out = '#New York Times\\n#Exported by Sudoku Player\\n';
  for(let r=0;r<9;r++){
    let row = '';
    for(let c=0;c<9;c++) row += (g[r][c] ? String(g[r][c]) : '.');
    out += row + '\\n';
  }
  const blob = new Blob([out],{type:'text/plain'});
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url; a.download = 'puzzle.sdk';
  a.click();
  URL.revokeObjectURL(url);
});

// solver (backtracking)
function isValid(grid, r, c, val){
  for(let i=0;i<9;i++){
    if(grid[r][i]===val) return false;
    if(grid[i][c]===val) return false;
  }
  const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
  for(let i=0;i<3;i++) for(let j=0;j<3;j++){
    if(grid[br+i][bc+j]===val) return false;
  }
  return true;
}

function findEmpty(grid){
  for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(grid[r][c]===0) return [r,c];
  return null;
}

function solveGrid(grid){
  const empty = findEmpty(grid);
  if(!empty) return true;
  const [r,c] = empty;
  for(let val=1; val<=9; val++){
    if(isValid(grid,r,c,val)){
      grid[r][c]=val;
      if(solveGrid(grid)) return true;
      grid[r][c]=0;
    }
  }
  return false;
}

document.getElementById('solveBtn').addEventListener('click', ()=>{
  const g = getGrid();
  const copy = g.map(r=>r.slice());
  if(!solveGrid(copy)){
    alert('No solution found (puzzle may be invalid).');
    return;
  }
  if(!confirm('Fill the board with the solution? (This will overwrite your entries)')) return;
  setGrid(copy,false);
});

// conflict finder
function findConflicts(g){
  const conflicts=[];
  for(let r=0;r<9;r++) for(let c=0;c<9;c++){
    const v = g[r][c];
    if(!v) continue;
    // check row/col/box for duplicate with different position
    for(let k=0;k<9;k++){
      if(k!==c && g[r][k]===v) conflicts.push({r,c});
      if(k!==r && g[k][c]===v) conflicts.push({r,c});
    }
    const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
    for(let i=0;i<3;i++) for(let j=0;j<3;j++){
      const rr=br+i, cc=bc+j;
      if((rr!==r || cc!==c) && g[rr][cc]===v) conflicts.push({r,c});
    }
  }
  // dedupe by key string
  const map = {};
  conflicts.forEach(x=> map[x.r+','+x.c]=x);
  return Object.values(map);
}

// initialize empty board
setGrid(Array.from({length:9},()=>Array(9).fill(0)),false);
</script>
</body>
</html>
