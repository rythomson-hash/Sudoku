<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sudoku Player â€” with Timer & Candidates</title>
<meta name="theme-color" content="#0b1220"/>
<style>
:root{
  --bg:#f6f8fb; --card:#ffffff; --muted:#6b7280; --accent:#0b84ff;
  --cell-bg:#fff; --cell-border:#d1d5db; --thick:#111827;
  --match:#fffbcc; --correct:#d1ffd8; --wrong:#ffd6d6;
}
[data-theme="dark"]{
  --bg:#07101a; --card:#08121a; --muted:#9aa4b2; --accent:#4aa8ff;
  --cell-bg:#07101a; --cell-border:#16222b; --thick:#e6eef8;
  --match:#2b3a2a; --correct:#123017; --wrong:#501212;
}
html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#e9eef8);font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial; -webkit-font-smoothing:antialiased;color:var(--thick);}
.wrap{max-width:920px;margin:18px auto;padding:16px;display:flex;flex-direction:column;gap:12px;}
.header{display:flex;align-items:center;gap:12px;}
.header h1{margin:0;font-size:18px;}
.header .meta{margin-left:auto;color:var(--muted);font-size:13px;}
.card{background:var(--card);border-radius:12px;padding:12px;box-shadow:0 6px 18px rgba(12,22,39,0.06);border:1px solid rgba(15,23,42,0.04);}
.controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
textarea{width:100%;min-height:86px;padding:10px;border-radius:8px;border:1px solid var(--cell-border);resize:vertical;background:transparent;color:inherit}
.btn{padding:10px 12px;border-radius:10px;border:0;background:var(--accent);color:white;font-weight:600;font-size:14px;cursor:pointer;box-shadow:0 6px 14px rgba(11,132,255,0.12)}
.btn.ghost{background:transparent;color:var(--muted);box-shadow:none;border:1px solid var(--cell-border)}
.small{font-size:12px;padding:8px 10px}
.board-wrap{display:flex;gap:16px;flex-direction:row;flex-wrap:wrap;align-items:flex-start;justify-content:center}
.board{display:grid;grid-template-columns:repeat(9,calc(100vmin/11));gap:6px;background:transparent;touch-action:manipulation;}
.cell{width:calc(100vmin/11);height:calc(100vmin/11);display:flex;align-items:center;justify-content:center;border-radius:8px;background:var(--cell-bg);border:1px solid var(--cell-border);box-shadow:0 1px 0 rgba(0,0,0,0.02) inset;position:relative;overflow:hidden;transition:transform .12s ease, box-shadow .12s ease, background-color .18s ease;}
.cell input{width:100%;height:100%;border:0;background:transparent;font-size:20px;text-align:center;font-weight:700;outline:none;color:var(--thick);cursor:default;z-index:3;}
@media(min-width:420px){ .board {grid-template-columns:repeat(9,48px);} .cell{width:48px;height:48px;} .cell input{font-size:20px;} }
.cell.box-right{border-right:3px solid var(--thick);}
.cell.box-bottom{border-bottom:3px solid var(--thick);}
.clue input{font-weight:900;color:var(--thick);}
.selected{box-shadow:0 6px 20px rgba(11,132,255,0.14);transform:translateY(-2px);}
.match{background:var(--match);}
.correct-pulse{animation:correct-pulse .8s ease forwards;}
@keyframes correct-pulse{0%{background:var(--correct);transform:scale(1.02);}50%{transform:scale(1.03);}100%{transform:none;background:transparent;}}
.red-flash{animation:red-flash .8s ease forwards;}
@keyframes red-flash{0%{background:var(--wrong);transform:translateY(-2px);}60%{transform:translateY(0);}100%{background:transparent;}}
.glow{transition:box-shadow .25s ease;box-shadow:0 0 18px rgba(11,132,255,0.16);}
.conflict{outline:3px solid rgba(255,80,80,0.9);box-shadow:0 8px 30px rgba(255,40,40,0.06);}

/* candidate grid (3x3 small numbers) */
.candidates{position:absolute;left:6px;top:6px;right:6px;bottom:6px;display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);gap:0;font-size:9px;color:var(--muted);align-items:start;pointer-events:none;z-index:1}
.candidates span{display:flex;align-items:center;justify-content:center;opacity:0.95;pointer-events:auto;cursor:pointer}
.candidates span.hidden{opacity:0;}
.candidates span.active{color:var(--thick);font-weight:700}
.cell.pencil-mode .candidates{pointer-events:auto}
#confettiCanvas{position:fixed;left:0;top:0;pointer-events:none;width:100%;height:100%;z-index:9999;}
.footer{font-size:13px;color:var(--muted);margin-top:8px}
.toggle{margin-left:auto;padding:8px;border-radius:8px;border:1px solid var(--cell-border);cursor:pointer;background:transparent}

/* timer layout */
.timerBox{display:flex;align-items:center;gap:8px;margin-left:6px}
.timeDisplay{background:rgba(0,0,0,0.04);padding:6px 10px;border-radius:8px;font-weight:700}
.bestTime{font-size:12px;color:var(--muted)}
</style>
</head>
<body>
<canvas id="confettiCanvas"></canvas>
<div class="wrap">
  <div class="header">
    <h1>Sudoku Player</h1>
    <div class="meta">Auto candidates â€¢ Timer â€¢ Pencil mode</div>
  </div>

  <div class="card">
    <div style="display:flex;gap:12px;align-items:flex-start">
      <div style="flex:1">
        <textarea id="raw" placeholder="Paste .sdk content or 9 rows (use '.' for blanks)"></textarea>
        <div style="margin-top:8px;display:flex;gap:8px;align-items:center;flex-wrap:wrap">
          <button id="parseBtn" class="btn small">Parse & Load</button>
          <button id="hintBtn" class="btn small" style="background:linear-gradient(180deg,#ffb86b,#ff8f3b)">Hint (1)</button>
          <button id="solveBtn" class="btn small">Auto-solve</button>
          <button id="checkBtn" class="btn ghost small">Check</button>
          <button id="exportBtn" class="btn ghost small">Export .sdk</button>
          <button id="autoCands" class="btn ghost small">Auto Candidates: OFF</button>
          <button id="pencilToggle" class="btn ghost small">Pencil Mode: OFF</button>
          <div class="timerBox">
            <div class="timeDisplay" id="timeDisplay">00:00</div>
            <button id="timerStart" class="btn small">Start</button>
            <button id="timerPause" class="btn ghost small">Pause</button>
            <button id="timerReset" class="btn ghost small">Reset</button>
            <div style="display:flex;flex-direction:column;align-items:flex-end">
              <div class="bestTime" id="bestTime">Best: â€”</div>
              <div class="bestTime" style="font-size:11px;color:var(--muted)">Auto-start on parse/type</div>
            </div>
          </div>
        </div>
      </div>
    </div>

    <div style="height:12px"></div>

    <div class="board-wrap" style="justify-content:center">
      <div id="board" class="board" aria-label="Sudoku board"></div>
    </div>

    <div class="footer" style="display:flex;align-items:center;gap:8px">
      <div>Tap a cell to type. Use Hint for one-cell help. Conflicts are highlighted in red.</div>
      <button id="clearBtn" class="btn ghost small" style="margin-left:auto">Clear</button>
      <button id="theme" class="toggle small">Toggle Dark</button>
    </div>
  </div>
</div>

<script>
(() => {
  const board = document.getElementById('board');
  const raw = document.getElementById('raw');
  const parseBtn = document.getElementById('parseBtn');
  const solveBtn = document.getElementById('solveBtn');
  const hintBtn = document.getElementById('hintBtn');
  const checkBtn = document.getElementById('checkBtn');
  const exportBtn = document.getElementById('exportBtn');
  const clearBtn = document.getElementById('clearBtn');
  const autoCandsBtn = document.getElementById('autoCands');
  const pencilBtn = document.getElementById('pencilToggle');
  const themeBtn = document.getElementById('theme');

  // timer elements
  const timeDisplay = document.getElementById('timeDisplay');
  const timerStart = document.getElementById('timerStart');
  const timerPause = document.getElementById('timerPause');
  const timerReset = document.getElementById('timerReset');
  const bestTimeLabel = document.getElementById('bestTime');

  const confettiCanvas = document.getElementById('confettiCanvas');
  const ctx = confettiCanvas.getContext && confettiCanvas.getContext('2d');

  let autoCandidates = false;
  let pencilMode = false;
  let cachedSolution = null;
  let confettiAnimating = false;

  // timer state
  let timerInterval = null;
  let elapsedMs = 0;
  let timerRunning = false;
  let timerStartTs = 0;

  function resizeCanvas(){ confettiCanvas.width = innerWidth; confettiCanvas.height = innerHeight; }
  addEventListener('resize', resizeCanvas); resizeCanvas();

  // create grid elements (each cell contains input + candidates overlay)
  const cells = [];
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      const div = document.createElement('div'); div.className='cell';
      if((c+1)%3===0 && c!==8) div.classList.add('box-right');
      if((r+1)%3===0 && r!==8) div.classList.add('box-bottom');
      const inp = document.createElement('input'); inp.type='tel'; inp.inputMode='numeric'; inp.maxLength=1; inp.autocomplete='off';
      inp.addEventListener('input', e=> { e.target.value = e.target.value.replace(/[^1-9]/g,''); onCellInput(div, inp); });
      inp.addEventListener('focus', ()=> onCellFocus(div, inp));
      inp.addEventListener('blur', ()=> onCellBlur(div, inp));
      inp.addEventListener('keydown', (e)=> { if(e.key==='Backspace' || e.key==='Delete') e.target.value=''; });
      const cand = document.createElement('div'); cand.className='candidates';
      for(let v=1; v<=9; v++){
        const s = document.createElement('span');
        s.textContent = v;
        s.dataset.val = v;
        s.className = 'hidden';
        s.addEventListener('click', (ev)=> {
          ev.stopPropagation();
          if(!pencilMode) return;
          s.classList.toggle('active');
        });
        cand.appendChild(s);
      }
      div.appendChild(inp);
      div.appendChild(cand);
      board.appendChild(div);
      cells.push({div,inp,cand,r,c});
    }
  }

  // helper grid getters/setters
  function getGrid(){
    const g = Array.from({length:9}, ()=>Array(9).fill(0));
    for(let i=0;i<81;i++){
      const r = Math.floor(i/9), c = i%9, v = cells[i].inp.value.trim();
      g[r][c] = v===''?0:parseInt(v,10);
    }
    return g;
  }
  function setGrid(grid, clues=false){
    for(let r=0;r<9;r++) for(let c=0;c<9;c++){
      const i = r*9+c; const v = (grid[r] && grid[r][c]) ? String(grid[r][c]) : '';
      cells[i].inp.value = v;
      if(clues && v){ cells[i].div.classList.add('clue'); cells[i].inp.readOnly=true; } 
      else { cells[i].div.classList.remove('clue'); cells[i].inp.readOnly=false; }
    }
    refreshCandidates();
    checkAndMarkConflicts();
  }

  // parser (accepts .sdk comments or 9 rows or 81-char string)
  function parseText(txt){
    if(!txt) return null;
    const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(s=> s!=='' && !s.startsWith('#'));
    if(lines.length>=9){
      const rows = [];
      for(let i=0;i<9;i++){
        const l = lines[i] || '';
        const filtered = l.replace(/[^0-9.]/g,'.');
        const row = [];
        for(const ch of filtered){
          if(ch==='.') row.push(0); else row.push(parseInt(ch,10));
          if(row.length===9) break;
        }
        while(row.length<9) row.push(0);
        rows.push(row);
      }
      return rows;
    }
    const compact = txt.replace(/[^0-9.]/g,'');
    if(compact.length>=81){
      const s = compact.slice(0,81);
      const rows = [];
      for(let r=0;r<9;r++) rows.push(Array.from(s.slice(r*9,(r+1)*9)).map(ch=> ch==='.'?0:parseInt(ch,10)));
      return rows;
    }
    return null;
  }

  // solver utilities
  function isValid(grid,r,c,val){
    for(let i=0;i<9;i++){ if(grid[r][i]===val) return false; if(grid[i][c]===val) return false; }
    const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
    for(let i=0;i<3;i++) for(let j=0;j<3;j++) if(grid[br+i][bc+j]===val) return false;
    return true;
  }
  function findEmpty(grid){
    for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(grid[r][c]===0) return [r,c];
    return null;
  }
  function solveGrid(grid){
    const empty = findEmpty(grid); if(!empty) return true;
    const [r,c] = empty;
    for(let v=1; v<=9; v++){
      if(isValid(grid,r,c,v)){ grid[r][c]=v; if(solveGrid(grid)) return true; grid[r][c]=0; }
    }
    return false;
  }

  // conflict detection
  function findConflicts(g){
    const list=[];
    for(let r=0;r<9;r++){
      for(let c=0;c<9;c++){
        const v = g[r][c]; if(!v) continue;
        for(let k=0;k<9;k++){
          if(k!==c && g[r][k]===v) list.push([r,c]);
          if(k!==r && g[k][c]===v) list.push([r,c]);
        }
        const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
        for(let i=0;i<3;i++) for(let j=0;j<3;j++){
          const rr=br+i, cc=bc+j;
          if((rr!==r || cc!==c) && g[rr][cc]===v) list.push([r,c]);
        }
      }
    }
    const seen={}; return list.filter(([r,c])=>{ const k=r+','+c; if(seen[k]) return false; seen[k]=1; return true; });
  }

  function checkAndMarkConflicts(){
    // clear
    cells.forEach(c=> c.div.classList.remove('conflict'));
    const g = getGrid();
    const conf = findConflicts(g);
    if(conf.length>0){
      for(const [r,c] of conf){ cells[r*9+c].div.classList.add('conflict'); }
    }
    return conf;
  }

  // candidates: compute and display
  function computeCandidatesForCell(g,r,c){
    if(g[r][c]!==0) return [];
    const arr=[];
    for(let v=1; v<=9; v++) if(isValid(g,r,c,v)) arr.push(v);
    return arr;
  }
  function refreshCandidates(){
    const g = getGrid();
    for(let i=0;i<81;i++){
      const {cand, inp} = cells[i];
      const spans = cand.querySelectorAll('span');
      const v = parseInt(inp.value || 0,10);
      if(v){
        spans.forEach(s=> s.classList.add('hidden')); continue;
      }
      const r = Math.floor(i/9), c = i%9;
      const possible = computeCandidatesForCell(g,r,c);
      spans.forEach(s=>{
        const val = parseInt(s.dataset.val,10);
        if(possible.includes(val)){ s.classList.remove('hidden'); s.classList.remove('active'); }
        else { s.classList.add('hidden'); s.classList.remove('active'); }
      });
    }
  }

  // UI button behaviors
  parseBtn.addEventListener('click', ()=>{
    const grid = parseText(raw.value);
    if(!grid){ alert('Could not parse â€” paste the 9 rows or the .sdk content.'); return; }
    setGrid(grid,true);
    cachedSolution = null;
    const conf = checkAndMarkConflicts();
    if(conf.length>0){
      const coords = conf.map(([r,c])=>`(${r+1},${c+1})`).join(', ');
      alert('Parsed puzzle has conflicting clues at: ' + coords + '\nPlease correct these cells (they are highlighted) before solving.');
    } else {
      if(autoCandidates) refreshCandidates();
    }
    // timer: reset and auto-start
    resetTimer();
    startTimer(); // auto-start on parse
    // update best label for this puzzle key
    updateBestLabel();
  });

  clearBtn.addEventListener('click', ()=>{ setGrid(Array.from({length:9}, ()=>Array(9).fill(0)), false); cachedSolution=null; resetTimer(); updateBestLabel(); });

  exportBtn.addEventListener('click', ()=>{
    const g = getGrid(); let out = '#Exported from Sudoku Player\n';
    for(let r=0;r<9;r++) out += g[r].map(v=> v?String(v):'.').join('') + '\n';
    const b = new Blob([out], {type:'text/plain'}); const url = URL.createObjectURL(b); const a = document.createElement('a'); a.href=url; a.download='puzzle.sdk'; a.click(); URL.revokeObjectURL(url);
  });

  hintBtn.addEventListener('click', ()=>{
    if(checkAndMarkConflicts().length>0){ alert('Fix conflicts before asking for a hint.'); return; }
    if(!cachedSolution) cachedSolution = computeSolution();
    if(!cachedSolution){ alert('No solution could be found for this puzzle (it may be invalid).'); return; }
    const g = getGrid(); const empties=[];
    for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(g[r][c]===0) empties.push([r,c]);
    if(empties.length===0){ alert('No empty cells â€” puzzle is filled.'); return; }
    let best=null, bestCnt=99;
    for(const [r,c] of empties){ let cnt=0; for(let v=1; v<=9; v++) if(isValid(g,r,c,v)) cnt++; if(cnt < bestCnt){ bestCnt=cnt; best=[r,c]; } }
    const [rr,cc] = best || empties[0]; const idx = rr*9+cc;
    const val = cachedSolution[rr][cc];
    cells[idx].inp.value = String(val);
    cells[idx].div.classList.add('correct-pulse');
    setTimeout(()=> cells[idx].div.classList.remove('correct-pulse'), 900);
    cachedSolution = computeSolution();
    refreshCandidates();
    setTimeout(()=>{ if(isSolvedAndValid()) onSolved(); }, 300);
  });

  solveBtn.addEventListener('click', ()=>{
    if(checkAndMarkConflicts().length>0){ alert('Fix conflicts before solving. Conflicting cells are highlighted.'); return; }
    const sol = cachedSolution || computeSolution();
    if(!sol){ alert('No solution found for current grid.'); return; }
    if(!confirm('Fill the entire grid with the solver answer?')) return;
    setGrid(sol,false);
    cachedSolution = sol;
    setTimeout(()=> onSolved(), 300);
  });

  checkBtn.addEventListener('click', ()=>{
    if(checkAndMarkConflicts().length>0){ alert('Fix conflicts highlighted in red first.'); return; }
    const sol = cachedSolution || computeSolution();
    if(!sol){ alert('Cannot check: puzzle has no single valid solution or is invalid.'); return; }
    const g = getGrid(); const wrong=[];
    for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(g[r][c]!==0 && g[r][c]!==sol[r][c]) wrong.push([r,c]);
    if(wrong.length===0){ alert('All entered digits match the solver (so far).'); if(isSolvedAndValid()) onSolved(); return; }
    for(const [r,c] of wrong){ const idx = r*9+c; const d = cells[idx].div; d.classList.add('red-flash'); setTimeout(()=> d.classList.remove('red-flash'), 900); }
  });

  autoCandsBtn.addEventListener('click', ()=>{
    autoCandidates = !autoCandidates;
    autoCandsBtn.textContent = 'Auto Candidates: ' + (autoCandidates? 'ON':'OFF');
    if(autoCandidates) refreshCandidates(); else cells.forEach(c=> c.cand.querySelectorAll('span').forEach(s=> s.classList.add('hidden')));
  });

  pencilBtn.addEventListener('click', ()=>{
    pencilMode = !pencilMode;
    pencilBtn.textContent = 'Pencil Mode: ' + (pencilMode? 'ON':'OFF');
    cells.forEach(c=> c.div.classList.toggle('pencil-mode', pencilMode));
  });

  // timer functions
  function formatTime(ms){
    const totalSec = Math.floor(ms/1000);
    const mm = Math.floor(totalSec/60).toString().padStart(2,'0');
    const ss = (totalSec%60).toString().padStart(2,'0');
    return mm + ':' + ss;
  }
  function updateDisplay(){ timeDisplay.textContent = formatTime(elapsedMs); }
  function startTimer(){
    if(timerRunning) return;
    timerRunning = true;
    timerStartTs = Date.now();
    timerInterval = setInterval(()=>{
      elapsedMs += Date.now() - timerStartTs;
      timerStartTs = Date.now();
      updateDisplay();
    }, 250);
    timerStart.textContent = 'Running';
  }
  function pauseTimer(){ if(!timerRunning) return; timerRunning = false; clearInterval(timerInterval); timerInterval = null; timerStart.textContent = 'Start'; }
  function resetTimer(){ pauseTimer(); elapsedMs = 0; updateDisplay(); }

  timerStart.addEventListener('click', ()=> startTimer());
  timerPause.addEventListener('click', ()=> pauseTimer());
  timerReset.addEventListener('click', ()=> resetTimer());

  // auto-start on first typed digit in the board
  cells.forEach(c=>{
    c.inp.addEventListener('input', ()=>{
      if(!timerRunning && elapsedMs===0){ startTimer(); }
    });
  });

  // solution helper
  function computeSolution(){
    const g = getGrid(); const copy = g.map(r=> r.slice());
    if(!solveGrid(copy)) return null; return copy;
  }
  function isSolvedAndValid(){
    const sol = cachedSolution || computeSolution(); if(!sol) return false;
    const g = getGrid(); for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(g[r][c] !== sol[r][c]) return false;
    return true;
  }

  // on solved actions
  function onSolved(){
    pauseTimer();
    launchConfetti();
    const puzzleKey = getPuzzleStorageKey();
    const prev = localStorage.getItem(puzzleKey);
    const timeMs = elapsedMs;
    let bestChanged = false;
    if(!prev || timeMs < parseInt(prev,10)){
      localStorage.setItem(puzzleKey, String(timeMs));
      bestChanged = true;
    }
    updateBestLabel();
    setTimeout(()=> alert('Puzzle complete! Time: ' + formatTime(timeMs) + (bestChanged? ' â€” NEW BEST!':'') ), 200);
  }

  function getPuzzleStorageKey(){
    const text = raw.value || '';
    try{
      const key = 'sudoku_best_' + btoa(text);
      return key;
    } catch(e){
      return 'sudoku_best_default';
    }
  }
  function updateBestLabel(){
    const key = getPuzzleStorageKey();
    const t = localStorage.getItem(key);
    if(t) bestTimeLabel.textContent = 'Best: ' + formatTime(parseInt(t,10));
    else bestTimeLabel.textContent = 'Best: â€”';
  }

  // input focus/blur handlers
  function onCellFocus(div, inp){
    cells.forEach(x=> x.div.classList.remove('match','selected','glow'));
    div.classList.add('selected','glow');
    const v = inp.value.trim();
    if(v){ cells.forEach(x=> { if(x.inp.value.trim() === v) x.div.classList.add('match'); }); }
  }
  function onCellBlur(div, inp){
    setTimeout(()=> { div.classList.remove('selected','glow'); cells.forEach(x=> x.div.classList.remove('match')); }, 220);
    cachedSolution = null;
    refreshCandidates();
    checkAndMarkConflicts();
    if(isSolvedAndValid()) onSolved();
  }
  function onCellInput(div, inp){
    const val = inp.value.trim();
    if(val) div.querySelectorAll('.candidates span').forEach(s=> s.classList.add('hidden'));
    if(autoCandidates) refreshCandidates();
    cachedSolution = null;
    checkAndMarkConflicts();
  }

  // confetti (lightweight)
  function rand(min,max){ return Math.random()*(max-min)+min; }
  function launchConfetti(){
    if(!ctx) return; if(confettiAnimating) return; confettiAnimating = true;
    const w = confettiCanvas.width, h = confettiCanvas.height; let particles=[];
    const colors = ['#FF6B6B','#FFD93D','#6BCB77','#4D96FF','#C084FC']; const count = Math.min(140, Math.floor((w*h)/30000));
    for(let i=0;i<count;i++) particles.push({x:rand(0,w), y:rand(-h*0.6,0), vx:rand(-2,2), vy:rand(2,6), size:rand(6,12), rot:rand(0,360), color: colors[Math.floor(Math.random()*colors.length)], life:rand(60,140)});
    function step(){ ctx.clearRect(0,0,w,h); for(const p of particles){ p.x+=p.vx; p.y+=p.vy; p.vy+=0.06; p.rot+=6; p.life--; ctx.save(); ctx.translate(p.x,p.y); ctx.rotate((p.rot*Math.PI)/180); ctx.fillStyle=p.color; ctx.fillRect(-p.size/2,-p.size/2,p.size,p.size*0.6); ctx.restore(); } particles = particles.filter(p=>p.life>0 && p.y < h+50); if(particles.length>0) requestAnimationFrame(step); else { confettiAnimating=false; ctx.clearRect(0,0,w,h);} }
    step();
  }

  // candidate click behavior (non-pencil mode inserts digit)
  cells.forEach((c, idx) => {
    c.cand.querySelectorAll('span').forEach(span=>{
      span.addEventListener('click', (ev)=>{
        ev.stopPropagation();
        const val = span.dataset.val;
        if(pencilMode){
          span.classList.toggle('active');
          return;
        } else {
          c.inp.focus();
          c.inp.value = val;
          c.cand.querySelectorAll('span').forEach(s=> s.classList.add('hidden'));
          if(autoCandidates) refreshCandidates();
          cachedSolution = null;
          checkAndMarkConflicts();
          if(isSolvedAndValid()) onSolved();
        }
      });
    });
  });

  // theme toggle
  function setTheme(t){ document.documentElement.setAttribute('data-theme', t); themeBtn.textContent = t==='dark' ? 'Light' : 'Dark'; }
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  setTheme(prefersDark ? 'dark' : 'light');
  themeBtn.addEventListener('click', ()=>{ const cur = document.documentElement.getAttribute('data-theme')==='dark' ? 'dark' : 'light'; setTheme(cur === 'dark' ? 'light' : 'dark'); });

  // initial UI state
  updateBestLabel();
  setGrid(Array.from({length:9}, ()=>Array(9).fill(0)), false);

})();
</script>
</body>
</html>
  @media(min-width:420px){ .board {grid-template-columns:repeat(9,48px);} .cell{width:48px;height:48px;} .cell input{font-size:20px;} }

  /* 3x3 box thick borders */
  .cell.box-right{border-right:3px solid var(--thick);}
  .cell.box-bottom{border-bottom:3px solid var(--thick);}

  .clue input{font-weight:900;color:var(--thick);}
  .selected{box-shadow:0 6px 20px rgba(11,132,255,0.14);transform:translateY(-2px);}
  .match{background:var(--match);}
  .correct-pulse{animation:correct-pulse .8s ease forwards;}
  @keyframes correct-pulse{0%{background:var(--correct);transform:scale(1.02);}50%{transform:scale(1.03);}100%{transform:none;background:transparent;}}

  .red-flash{animation:red-flash .8s ease forwards;}
  @keyframes red-flash{0%{background:var(--wrong);transform:translateY(-2px);}60%{transform:translateY(0);}100%{background:transparent;}}

  /* subtle glow on select */
  .glow{transition:box-shadow .25s ease;box-shadow:0 0 18px rgba(11,132,255,0.16);}

  .footer{font-size:13px;color:var(--muted);margin-top:8px}
  .actions{display:flex;gap:8px;flex-wrap:wrap;}
  .top-row{display:flex;gap:8px;align-items:center;}
  .toggle{margin-left:auto;padding:8px;border-radius:8px;border:1px solid var(--cell-border);cursor:pointer;background:transparent}
  .hintBtn{background:linear-gradient(180deg,#ffb86b,#ff8f3b);box-shadow:0 6px 14px rgba(255,140,60,0.18)}
  .center{display:flex;justify-content:center;align-items:center}
  /* confetti canvas overlay */
  #confettiCanvas{position:fixed;left:0;top:0;pointer-events:none;width:100%;height:100%;z-index:9999;}
  .small{font-size:12px;padding:8px 10px}
</style>
</head>
<body>
<canvas id="confettiCanvas"></canvas>
<div class="wrap" id="wrap">
  <header>
    <h1>Sudoku Player</h1>
    <div class="meta">Hints â€¢ Animations â€¢ Confetti</div>
  </header>

  <div class="card">
    <div class="top-row">
      <div style="flex:1">
        <textarea id="raw" placeholder="Paste .sdk content or 9 rows (use '.' for blanks)."></textarea>
      </div>
      <div style="display:flex;flex-direction:column;gap:8px;margin-left:8px">
        <button id="parseBtn" class="btn small">Parse & Load</button>
        <button id="hintBtn" class="btn hintBtn small">Hint (1 cell)</button>
        <button id="solveBtn" class="btn small">Auto-solve</button>
        <button id="checkBtn" class="btn ghost small">Check</button>
        <button id="exportBtn" class="btn ghost small">Export .sdk</button>
      </div>
    </div>

    <div style="height:12px"></div>

    <div class="board-wrap center">
      <div id="board" class="board" aria-label="Sudoku board"></div>
    </div>

    <div class="footer">
      <div style="display:flex;gap:12px;align-items:center">
        <div class="hint">Tap a cell to type. Use Hint for one-cell help. When you finish the puzzle you'll get confetti ðŸŽ‰</div>
        <button id="clearBtn" class="btn ghost small" style="margin-left:auto">Clear</button>
        <button id="theme" class="toggle small">Toggle Dark</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const board = document.getElementById('board');
  const raw = document.getElementById('raw');
  const confettiCanvas = document.getElementById('confettiCanvas');
  const ctx = confettiCanvas.getContext && confettiCanvas.getContext('2d');
  let particles = [];
  let confettiAnimating = false;

  function resizeCanvas(){
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // create grid
  const cells = [];
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      const div = document.createElement('div');
      div.className = 'cell';
      if((c+1)%3===0 && c!==8) div.classList.add('box-right');
      if((r+1)%3===0 && r!==8) div.classList.add('box-bottom');
      const inp = document.createElement('input');
      inp.type='tel'; inp.inputMode='numeric'; inp.maxLength=1; inp.autocomplete='off';
      inp.addEventListener('input', (e)=>{ e.target.value = e.target.value.replace(/[^1-9]/g,''); onCellInput(e.target); });
      inp.addEventListener('focus', (e)=> onCellFocus(e.target));
      inp.addEventListener('blur', (e)=> onCellBlur(e.target));
      inp.addEventListener('keydown', (e)=>{ if(e.key==='Backspace' || e.key==='Delete'){ e.target.value=''; } });
      div.appendChild(inp);
      board.appendChild(div);
      cells.push({div,inp,r,c});
    }
  }

  function onCellInput(target){
    // brief pulse for correct placement if matches solution
    // we'll check after user uses check or hint
  }

  function onCellFocus(target){
    clearHighlights();
    const val = target.value.trim();
    // highlight selected cell
    const parent = target.parentElement;
    parent.classList.add('selected','glow');
    // highlight matches
    if(val){
      for(let i=0;i<cells.length;i++){
        if(cells[i].inp.value.trim() === val){
          cells[i].div.classList.add('match');
        }
      }
    }
  }

  function onCellBlur(target){
    // remove selected/glow after small delay so taps still show effect
    const parent = target.parentElement;
    parent.classList.remove('selected','glow');
    // keep matches until the next focus event for clarity
    setTimeout(()=> clearHighlights(), 350);
  }

  function clearHighlights(){
    cells.forEach(c=>{ c.div.classList.remove('match'); });
  }

  function setGrid(grid, clues=false){
    for(let r=0;r<9;r++) for(let c=0;c<9;c++){
      const i = r*9+c;
      const v = (grid[r] && grid[r][c]) ? String(grid[r][c]) : '';
      cells[i].inp.value = v;
      if(clues && v){
        cells[i].div.classList.add('clue');
        cells[i].inp.readOnly = true;
      } else {
        cells[i].div.classList.remove('clue');
        cells[i].inp.readOnly = false;
      }
    }
  }

  function getGrid(){
    const g = Array.from({length:9},()=>Array(9).fill(0));
    for(let i=0;i<81;i++){
      const r=Math.floor(i/9), c=i%9;
      const v = cells[i].inp.value.trim();
      g[r][c] = v===''?0:parseInt(v,10);
    }
    return g;
  }

  // parser accepts .sdk with comments, 9 rows, or an 81-character compact string
  function parseText(txt){
    if(!txt) return null;
    const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(s=>s!=='' && !s.startsWith('#'));
    if(lines.length>=9){
      const rows=[];
      for(let i=0;i<9;i++){
        const l = lines[i] || '';
        const filtered = l.replace(/[^0-9.]/g,'.');
        const row = [];
        for(let ch of filtered){
          if(ch==='.') row.push(0);
          else row.push(parseInt(ch,10));
          if(row.length===9) break;
        }
        while(row.length<9) row.push(0);
        rows.push(row);
      }
      return rows;
    }
    const compact = txt.replace(/[^0-9.]/g,'');
    if(compact.length>=81){
      const rows=[];
      const s = compact.slice(0,81);
      for(let r=0;r<9;r++){
        rows.push(Array.from(s.slice(r*9,(r+1)*9)).map(ch=> ch==='.'?0:parseInt(ch,10)));
      }
      return rows;
    }
    return null;
  }

  // solver (backtracking)
  function isValid(grid,r,c,val){
    for(let i=0;i<9;i++){ if(grid[r][i]===val) return false; if(grid[i][c]===val) return false; }
    const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
    for(let i=0;i<3;i++) for(let j=0;j<3;j++) if(grid[br+i][bc+j]===val) return false;
    return true;
  }
  function findEmpty(grid){
    for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(grid[r][c]===0) return [r,c];
    return null;
  }
  function solveGrid(grid){
    const empty = findEmpty(grid);
    if(!empty) return true;
    const [r,c]=empty;
    for(let v=1; v<=9; v++){
      if(isValid(grid,r,c,v)){
        grid[r][c]=v;
        if(solveGrid(grid)) return true;
        grid[r][c]=0;
      }
    }
    return false;
  }

  // find conflicts (duplicates in row/col/box)
  function findConflicts(g){
    const list=[];
    for(let r=0;r<9;r++){
      for(let c=0;c<9;c++){
        const v=g[r][c];
        if(!v) continue;
        for(let k=0;k<9;k++){
          if(k!==c && g[r][k]===v) list.push([r,c]);
          if(k!==r && g[k][c]===v) list.push([r,c]);
        }
        const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
        for(let i=0;i<3;i++) for(let j=0;j<3;j++){
          const rr=br+i, cc=bc+j;
          if((rr!==r || cc!==c) && g[rr][cc]===v) list.push([r,c]);
        }
      }
    }
    const seen={};
    return list.filter(([r,c])=>{ const k=r+','+c; if(seen[k]) return false; seen[k]=1; return true; });
  }

  // UI buttons
  document.getElementById('parseBtn').addEventListener('click', ()=>{
    const grid = parseText(raw.value);
    if(!grid){ alert('Could not parse â€” paste the 9 rows or the .sdk content.'); return; }
    setGrid(grid,true);
    // clear old solution cache
    cachedSolution = null;
  });

  document.getElementById('clearBtn').addEventListener('click', ()=>{
    setGrid(Array.from({length:9}, ()=>Array(9).fill(0)), false);
    cachedSolution = null;
  });

  document.getElementById('exportBtn').addEventListener('click', ()=>{
    const g = getGrid();
    let out = '#Exported from Sudoku Player\\n';
    for(let r=0;r<9;r++) out += g[r].map(v=> v?String(v):'.').join('') + '\\n';
    const b = new Blob([out], {type:'text/plain'});
    const url = URL.createObjectURL(b);
    const a = document.createElement('a'); a.href=url; a.download='puzzle.sdk'; a.click(); URL.revokeObjectURL(url);
  });

  // compute and memoize solution for current clues (to speed hints/checks)
  let cachedSolution = null;
  function computeSolution(){
    const g = getGrid();
    const copy = g.map(r=>r.slice());
    if(!solveGrid(copy)) return null;
    return copy;
  }

  // Hint: fill a single cell (smart: choose empty cell with fewest candidates)
  document.getElementById('hintBtn').addEventListener('click', ()=>{
    // compute solution if not cached
    if(!cachedSolution) cachedSolution = computeSolution();
    if(!cachedSolution){ alert('No solution could be found for this puzzle (it may be invalid).'); return; }

    // find empty cells
    const g = getGrid();
    const empties = [];
    for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(g[r][c]===0) empties.push([r,c]);
    if(empties.length===0){ alert('No empty cells â€” puzzle is already filled.'); return; }

    // choose a "good" empty: fewest candidates by checking isValid
    let best = null, bestCount = 99;
    for(const [r,c] of empties){
      let cnt = 0;
      for(let v=1; v<=9; v++) if(isValid(g,r,c,v)) cnt++;
      if(cnt < bestCount){ bestCount = cnt; best = [r,c]; }
    }
    const [rr,cc] = best || empties[0];
    const i = rr*9 + cc;
    const value = cachedSolution[rr][cc];
    // set and animate the cell
    cells[i].inp.value = String(value);
    cells[i].div.classList.add('correct-pulse');
    // after animation remove class
    setTimeout(()=> cells[i].div.classList.remove('correct-pulse'), 900);
    // recompute solution cache to allow further hints
    cachedSolution = computeSolution();
    // check if finished
    setTimeout(()=>{ if(isSolvedAndValid()) launchConfetti(); }, 500);
  });

  document.getElementById('solveBtn').addEventListener('click', ()=>{
    let sol = cachedSolution || computeSolution();
    if(!sol){ alert('No solution found for current grid.'); return; }
    if(!confirm('Fill the entire grid with the solver answer?')) return;
    setGrid(sol,false);
    cachedSolution = sol;
    setTimeout(()=> launchConfetti(), 300);
  });

  // Check: compare current entries to solved grid; mark wrong cells with red flash
  document.getElementById('checkBtn').addEventListener('click', ()=>{
    const sol = cachedSolution || computeSolution();
    if(!sol){ alert('Cannot check: puzzle has no single valid solution or is invalid.'); return; }
    const g = getGrid();
    const wrong = [];
    for(let r=0;r<9;r++) for(let c=0;c<9;c++){
      if(g[r][c]!==0 && g[r][c] !== sol[r][c]) wrong.push([r,c]);
    }
    if(wrong.length===0){
      alert('All entered digits match the solver (so far).');
      if(isSolvedAndValid()) launchConfetti();
      return;
    }
    // flash wrong cells
    for(const [r,c] of wrong){
      const idx = r*9+c;
      const d = cells[idx].div;
      d.classList.add('red-flash');
      setTimeout(()=> d.classList.remove('red-flash'), 900);
    }
  });

  // is puzzle fully filled and matches solution
  function isSolvedAndValid(){
    const sol = cachedSolution || computeSolution();
    if(!sol) return false;
    const g = getGrid();
    for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(g[r][c] !== sol[r][c]) return false;
    return true;
  }

  // highlight matching numbers when a cell with a digit is tapped
  board.addEventListener('click', (ev)=>{
    const tgt = ev.target;
    if(tgt.tagName !== 'INPUT') return;
    // focus will handle highlights
  });

  // small theme toggle
  const themeBtn = document.getElementById('theme');
  function setTheme(t){
    document.documentElement.setAttribute('data-theme', t);
    themeBtn.textContent = t==='dark' ? 'Light' : 'Dark';
  }
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  setTheme(prefersDark ? 'dark' : 'light');
  themeBtn.addEventListener('click', ()=>{
    const cur = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light';
    setTheme(cur === 'dark' ? 'light' : 'dark');
  });

  // confetti implementation (lightweight)
  function rand(min,max){ return Math.random()*(max-min)+min; }
  function launchConfetti(){
    if(!ctx) return;
    if(confettiAnimating) return;
    confettiAnimating = true;
    const w = confettiCanvas.width, h = confettiCanvas.height;
    particles = [];
    const colors = ['#FF6B6B','#FFD93D','#6BCB77','#4D96FF','#C084FC'];
    const count = Math.min(100, Math.floor((w*h)/50000)); // scale by screen
    for(let i=0;i<count;i++){
      particles.push({
        x: rand(0,w), y: rand(-h*0.5,0),
        vx: rand(-2,2), vy: rand(2,6),
        size: rand(6,12), rot: rand(0,360), color: colors[Math.floor(Math.random()*colors.length)],
        life: rand(60,110)
      });
    }
    let tick = 0;
    function step(){
      tick++;
      ctx.clearRect(0,0,w,h);
      for(let p of particles){
        p.x += p.vx; p.y += p.vy; p.vy += 0.06; p.rot += 6;
        p.life--;
        ctx.save();
        ctx.translate(p.x,p.y);
        ctx.rotate((p.rot*Math.PI)/180);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.6);
        ctx.restore();
      }
      particles = particles.filter(p=>p.life>0 && p.y < h+50);
      if(particles.length>0) requestAnimationFrame(step);
      else { confettiAnimating=false; ctx.clearRect(0,0,w,h); }
    }
    step();
  }

  // initial empty board
  setGrid(Array.from({length:9}, ()=>Array(9).fill(0)), false);

  // small UX: when clicking a cell, show matching highlights immediately
  for(const c of cells){
    c.inp.addEventListener('focus', ()=>{
      const val = c.inp.value.trim();
      // clear previous
      cells.forEach(x=> x.div.classList.remove('match','selected','glow'));
      c.div.classList.add('selected','glow');
      if(val){
        for(const o of cells) if(o.inp.value.trim() === val) o.div.classList.add('match');
      }
    });
    c.inp.addEventListener('input', ()=>{
      // update matches on input
      const v = c.inp.value.trim();
      cells.forEach(x=> x.div.classList.remove('match'));
      if(v){
        for(const o of cells) if(o.inp.value.trim() === v) o.div.classList.add('match');
      }
    });
    c.inp.addEventListener('blur', ()=>{
      setTimeout(()=> cells.forEach(x=> x.div.classList.remove('selected','glow')), 200);
    });
  }

  // expose a small helper to load a sample quickly (for debugging)
  window.__loadSample = function(){
    const sample = [
      [2,0,0,0,0,0,0,0,0],
      [9,0,0,0,0,0,1,8,0],
      [8,0,7,0,4,3,0,6,5],
      [0,0,6,5,0,0,0,0,4],
      [0,0,0,0,0,0,0,6,0],
      [0,9,0,0,7,0,0,0,1],
      [0,0,0,8,3,0,0,0,0],
      [0,4,0,0,6,5,0,0,0],
      [0,5,0,2,0,0,0,7,0],
    ];
    setGrid(sample,true);
  };
})();

function setGrid(){ /* placeholder to satisfy some browsers if script splitting occurs */ }
</script>
</body>
</html>
