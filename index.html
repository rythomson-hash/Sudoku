<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1"/>
<title>NYT-style Sudoku — Fixed Pencil & Highlights</title>
<style>
:root{
  --bg:#f6f8fb; --card:#fff; --muted:#6b7280; --accent:#0b84ff;
  --cell-bg:#fff; --cell-border:#d1d5db; --thick:#111827;
  --match:#fffbcc; --conflict:#ffd6d6;
}
[data-theme="dark"]{
  --bg:#07101a; --card:#08121a; --muted:#9aa4b2; --accent:#4aa8ff;
  --cell-bg:#07101a; --cell-border:#16222b; --thick:#e6eef8;
  --match:#2b3a2a; --conflict:#501212;
}
html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#e9eef8);font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial;color:var(--thick)}
.wrap{max-width:920px;margin:18px auto;padding:16px}
.card{background:var(--card);border-radius:12px;padding:12px;box-shadow:0 6px 18px rgba(12,22,39,0.06);}
.board{display:grid;grid-template-columns:repeat(9,48px);gap:6px;justify-content:center}
.cell{width:48px;height:48px;display:flex;align-items:center;justify-content:center;border-radius:8px;background:var(--cell-bg);border:1px solid var(--cell-border);position:relative;overflow:hidden;cursor:pointer}
.cell input{width:100%;height:100%;border:0;background:transparent;font-size:20px;text-align:center;font-weight:700;outline:none;color:var(--thick)}
.cell.box-right{border-right:3px solid var(--thick)}
.cell.box-bottom{border-bottom:3px solid var(--thick)}
.selected{box-shadow:0 6px 20px rgba(11,132,255,0.14);transform:translateY(-2px)}
.match{background:var(--match)}
.conflict{outline:3px solid rgba(255,80,80,0.9);box-shadow:0 8px 30px rgba(255,40,40,0.06)}
.candidates{position:absolute;left:6px;top:6px;right:6px;bottom:6px;display:grid;grid-template-columns:repeat(3,1fr);grid-template-rows:repeat(3,1fr);gap:0;font-size:10px;color:var(--muted);align-items:start;pointer-events:none}
.candidates span{display:flex;align-items:center;justify-content:center;pointer-events:auto;cursor:pointer;opacity:1;transition:color .12s,transform .08s}
.candidates span.hidden{display:none;opacity:0}
.candidates span.active{color:var(--thick);font-weight:700}
.cell.pencil-mode .candidates{pointer-events:auto}
.controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;margin-bottom:12px}
.btn{padding:8px 10px;border-radius:8px;border:0;background:var(--accent);color:white;cursor:pointer}
.btn.ghost{background:transparent;color:var(--muted);border:1px solid var(--cell-border)}
.timeDisplay{background:rgba(0,0,0,0.04);padding:6px 10px;border-radius:8px;font-weight:700}
#confettiCanvas{position:fixed;left:0;top:0;width:100%;height:100%;pointer-events:none;z-index:9999}
</style>
</head>
<body>
<canvas id="confettiCanvas"></canvas>
<div class="wrap">
  <div class="card">
    <div class="controls">
      <textarea id="raw" placeholder="Paste 9 rows (. for blanks) or .sdk content" style="flex:1;min-height:64px;padding:8px;border-radius:8px;border:1px solid var(--cell-border)"></textarea>
      <div style="display:flex;flex-direction:column;gap:6px">
        <button id="parseBtn" class="btn">Parse & Load</button>
        <button id="exportBtn" class="btn ghost">Export .sdk</button>
        <button id="clearBtn" class="btn ghost">Clear</button>
      </div>
    </div>

    <div class="controls">
      <button id="pencilToggle" class="btn ghost">Pencil Mode: OFF</button>
      <button id="autoCands" class="btn ghost">Auto Candidates: ON</button>
      <button id="hintBtn" class="btn" style="background:linear-gradient(180deg,#ffb86b,#ff8f3b)">Hint</button>
      <button id="solveBtn" class="btn">Auto-solve</button>
      <button id="checkBtn" class="btn ghost">Check</button>

      <div style="margin-left:auto;display:flex;gap:8px;align-items:center">
        <div class="timeDisplay" id="timeDisplay">00:00</div>
        <button id="timerStart" class="btn small">Start</button>
        <button id="timerPause" class="btn ghost small">Pause</button>
        <button id="timerReset" class="btn ghost small">Reset</button>
        <div style="font-size:12px;color:var(--muted);margin-left:8px" id="bestTime">Best: —</div>
      </div>
    </div>

    <div class="board" id="board" aria-label="Sudoku board"></div>
  </div>
</div>

<script>
(() => {
  /* ---- Elements & state ---- */
  const board = document.getElementById('board');
  const raw = document.getElementById('raw');
  const parseBtn = document.getElementById('parseBtn');
  const exportBtn = document.getElementById('exportBtn');
  const clearBtn = document.getElementById('clearBtn');
  const pencilToggle = document.getElementById('pencilToggle');
  const autoCandsBtn = document.getElementById('autoCands');
  const hintBtn = document.getElementById('hintBtn');
  const solveBtn = document.getElementById('solveBtn');
  const checkBtn = document.getElementById('checkBtn');

  const timerStart = document.getElementById('timerStart');
  const timerPause = document.getElementById('timerPause');
  const timerReset = document.getElementById('timerReset');
  const timeDisplay = document.getElementById('timeDisplay');
  const bestTimeLabel = document.getElementById('bestTime');

  const confettiCanvas = document.getElementById('confettiCanvas');
  const ctx = confettiCanvas.getContext && confettiCanvas.getContext('2d');

  let pencilMode = false;
  let autoCandidates = true;
  let currentlyHighlightedVal = null;
  let cachedSolution = null;

  let timerInterval = null;
  let timerRunning = false;
  let timerStartTs = 0;
  let elapsedMs = 0;

  function resizeCanvas(){ if(confettiCanvas){ confettiCanvas.width = innerWidth; confettiCanvas.height = innerHeight; } }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  /* ---- Build board ---- */
  const cells = [];
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      const div = document.createElement('div');
      div.className = 'cell';
      if((c+1)%3===0 && c!==8) div.classList.add('box-right');
      if((r+1)%3===0 && r!==8) div.classList.add('box-bottom');

      const inp = document.createElement('input');
      inp.type = 'tel';
      inp.maxLength = 1;
      inp.autocomplete = 'off';

      const cand = document.createElement('div');
      cand.className = 'candidates';

      const candidatesSet = new Set(); // persistent pencil notes for this cell

      for(let v=1; v<=9; v++){
        const s = document.createElement('span');
        s.textContent = v;
        s.dataset.val = v;
        s.className = 'hidden';
        // click behavior for candidate span
        s.addEventListener('click', (ev) => {
          ev.stopPropagation();
          // compute possible for this cell now
          const g2 = grid2d();
          const possible = computeCandidatesForCell(g2, r, c);
          const val = parseInt(s.dataset.val, 10);
          if(pencilMode){
            // only allow toggling notes for currently possible candidates
            if(!possible.includes(val)) return;
            if(candidatesSet.has(val)){
              candidatesSet.delete(val);
              s.classList.remove('active');
            } else {
              candidatesSet.add(val);
              s.classList.add('active');
            }
            // do not insert the big number in pencil mode
            return;
          } else {
            // non-pencil mode -> insert number and permanently highlight
            inp.value = String(val);
            candidatesSet.clear();
            refreshAll();
            currentlyHighlightedVal = val;
            highlightMatches(currentlyHighlightedVal);
            cachedSolution = null;
            if(isSolvedAndValid()) solvedActions();
            return;
          }
        });
        cand.appendChild(s);
      }

      inp.addEventListener('input', () => {
        inp.value = inp.value.replace(/[^1-9]/g,'');
        // typing clears any pencil notes for that cell
        candidatesSet.clear();
        refreshAll();
        cachedSolution = null;
        const v = parseInt(inp.value||0,10);
        if(v) { currentlyHighlightedVal = v; highlightMatches(v); }
        if(!timerRunning && elapsedMs===0) startTimer();
        if(isSolvedAndValid()) solvedActions();
      });

      // do not clear highlight on blur — permanent highlights requested
      inp.addEventListener('focus', ()=> { div.classList.add('selected'); const v=parseInt(inp.value||0,10); if(v){ currentlyHighlightedVal = v; highlightMatches(v); } });
      inp.addEventListener('blur', ()=> { div.classList.remove('selected'); });

      // clicking the cell (outside span) toggles permanent highlight (NYT behavior)
      div.addEventListener('click', (ev) => {
        if(ev.target.tagName.toLowerCase() === 'span') return; // handled by span
        const val = parseInt(inp.value||0,10);
        if(!val) return;
        if(currentlyHighlightedVal === val) { currentlyHighlightedVal = null; highlightMatches(null); }
        else { currentlyHighlightedVal = val; highlightMatches(val); }
      });

      div.appendChild(inp);
      div.appendChild(cand);
      board.appendChild(div);

      cells.push({div, inp, cand, r, c, candidatesSet});
    }
  }

  /* ---- Grid helpers ---- */
  function grid2d(){
    const g = Array.from({length:9}, ()=>Array(9).fill(0));
    for(const cell of cells){
      const v = parseInt(cell.inp.value||0,10);
      g[cell.r][cell.c] = v;
    }
    return g;
  }

  /* ---- Validation & solver ---- */
  function isValid(g, r, c, val){
    for(let i=0;i<9;i++){
      if(g[r][i] === val) return false;
      if(g[i][c] === val) return false;
    }
    const br = Math.floor(r/3)*3, bc = Math.floor(c/3)*3;
    for(let i=0;i<3;i++) for(let j=0;j<3;j++){
      if(g[br+i][bc+j] === val) return false;
    }
    return true;
  }

  function computeCandidatesForCell(g, r, c){
    if(g[r][c] !== 0) return [];
    const arr = [];
    for(let v=1; v<=9; v++) if(isValid(g, r, c, v)) arr.push(v);
    return arr;
  }

  function findEmpty(g){
    for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(g[r][c]===0) return [r,c];
    return null;
  }
  function solveGrid(g){
    const e = findEmpty(g);
    if(!e) return true;
    const [r,c] = e;
    for(let v=1; v<=9; v++){
      if(isValid(g, r, c, v)){
        g[r][c] = v;
        if(solveGrid(g)) return true;
        g[r][c] = 0;
      }
    }
    return false;
  }
  function computeSolution(){
    const g = grid2d().map(row => row.slice());
    if(!solveGrid(g)) return null;
    return g;
  }

  /* ---- Conflicts ---- */
  function checkConflicts(){
    const g = grid2d();
    let ok = true;
    cells.forEach(c => c.div.classList.remove('conflict'));
    for(let r=0;r<9;r++) for(let c=0;c<9;c++){
      const v = g[r][c]; if(!v) continue;
      g[r][c] = 0;
      if(!isValid(g, r, c, v)){ cells[r*9+c].div.classList.add('conflict'); ok = false; }
      g[r][c] = v;
    }
    return ok;
  }

  /* ---- Candidates display + pencil notes ----
     Behavior requested:
     - Only show currently possible candidates (no ghosting)
     - In pencilMode: user can toggle notes, but only for possible candidates
     - If cell has explicit notes (candidatesSet), show those active
  */
  function refreshCandidatesForCell(cell){
    const g = grid2d();
    const spans = Array.from(cell.cand.querySelectorAll('span'));
    const val = parseInt(cell.inp.value||0,10);
    if(val){
      spans.forEach(s => { s.classList.add('hidden'); s.classList.remove('active'); s.style.opacity = '1'; });
      return;
    }
    const possible = computeCandidatesForCell(g, cell.r, cell.c);

    // If user-created notes exist, show only those (but still ensure they are possible)
    if(cell.candidatesSet.size > 0){
      spans.forEach(s=>{
        const v = parseInt(s.dataset.val,10);
        if(cell.candidatesSet.has(v) && possible.includes(v)){
          s.classList.remove('hidden');
          s.classList.add('active');
          s.style.opacity = '1';
        } else {
          s.classList.add('hidden');
          s.classList.remove('active');
        }
      });
      return;
    }

    // otherwise show computed possible candidates only
    spans.forEach(s=>{
      const v = parseInt(s.dataset.val,10);
      if(possible.includes(v)){
        s.classList.remove('hidden');
        s.classList.remove('active');
        s.style.opacity = '1';
      } else {
        s.classList.add('hidden');
        s.classList.remove('active');
      }
    });
  }

  function refreshAll(){
    for(const cell of cells) refreshCandidatesForCell(cell);
    checkConflicts();
  }

  /* ---- Highlighting (PERMANENT until toggled) ---- */
  function highlightMatches(val){
    currentlyHighlightedVal = val;
    cells.forEach(c => c.div.classList.remove('match'));
    cells.forEach(c => c.cand.querySelectorAll('span').forEach(s=> s.classList.remove('active')));
    if(!val) return;
    for(const c of cells){
      if(String(c.inp.value) === String(val)) c.div.classList.add('match');
      if(pencilMode){
        // also visually accent matching small candidates (if visible)
        c.cand.querySelectorAll('span').forEach(s=>{
          if(parseInt(s.dataset.val,10) === val && !s.classList.contains('hidden')) s.classList.add('active');
        });
      }
    }
  }

  /* ---- Solved check and actions ---- */
  function isSolvedAndValid(){
    const sol = cachedSolution || computeSolution();
    if(!sol) return false;
    const g = grid2d();
    for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(g[r][c] !== sol[r][c]) return false;
    return true;
  }

  function solvedActions(){
    pauseTimer();
    launchConfetti();
    const key = getPuzzleKey();
    const prev = localStorage.getItem(key);
    const timeMs = elapsedMs;
    let newBest = false;
    if(!prev || timeMs < parseInt(prev,10)){
      localStorage.setItem(key, String(timeMs));
      newBest = true;
    }
    updateBest();
    setTimeout(()=> alert('Puzzle complete! Time: ' + formatTime(timeMs) + (newBest ? ' — NEW BEST!' : '')), 200);
  }

  function getPuzzleKey(){
    try { return 'sudoku_best_' + btoa(raw.value || ''); } catch { return 'sudoku_best_default'; }
  }
  function updateBest(){
    const key = getPuzzleKey();
    const t = localStorage.getItem(key);
    bestTimeLabel.textContent = t ? 'Best: ' + formatTime(parseInt(t,10)) : 'Best: —';
  }

  /* ---- Timer ---- */
  function formatTime(ms){
    const s = Math.floor(ms/1000);
    const mm = String(Math.floor(s/60)).padStart(2,'0');
    const ss = String(s%60).padStart(2,'0');
    return mm + ':' + ss;
  }
  function updateDisplay(){ timeDisplay.textContent = formatTime(elapsedMs); }

  function startTimer(){
    if(timerRunning) return;
    timerRunning = true;
    timerStartTs = Date.now() - elapsedMs;
    timerInterval = setInterval(()=>{ elapsedMs = Date.now() - timerStartTs; updateDisplay(); }, 250);
  }
  function pauseTimer(){
    if(!timerRunning) return;
    timerRunning = false;
    clearInterval(timerInterval);
  }
  function resetTimer(){
    pauseTimer();
    elapsedMs = 0;
    updateDisplay();
  }

  timerStart.addEventListener('click', startTimer);
  timerPause.addEventListener('click', pauseTimer);
  timerReset.addEventListener('click', resetTimer);

  /* ---- Confetti ---- */
  function random(min,max){ return Math.random()*(max-min)+min; }
  function launchConfetti(){
    if(!ctx || confettiAnimating) return;
    confettiAnimating = true;
    const w = confettiCanvas.width, h = confettiCanvas.height;
    const colors = ['#FF6B6B','#FFD93D','#6BCB77','#4D96FF','#C084FC'];
    const count = Math.min(140, Math.floor((w*h)/30000));
    let parts = [];
    for(let i=0;i<count;i++){
      parts.push({x: random(0,w), y: random(-h*0.6,0), vx: random(-2,2), vy: random(2,6), size: random(6,12), rot: random(0,360), color: colors[Math.floor(Math.random()*colors.length)], life: random(60,140)});
    }
    function step(){
      ctx.clearRect(0,0,w,h);
      parts.forEach(p=>{
        p.x += p.vx; p.y += p.vy; p.vy += 0.06; p.rot += 6; p.life--;
        ctx.save(); ctx.translate(p.x,p.y); ctx.rotate(p.rot*Math.PI/180); ctx.fillStyle=p.color; ctx.fillRect(-p.size/2,-p.size/2,p.size,p.size*0.6); ctx.restore();
      });
      parts = parts.filter(p=>p.life>0 && p.y < h+50);
      if(parts.length>0) requestAnimationFrame(step); else { confettiAnimating=false; ctx.clearRect(0,0,w,h); }
    }
    step();
  }

  /* ---- UI actions ---- */

  parseBtn.addEventListener('click', ()=>{
    const lines = raw.value.split(/\r?\n/).map(s=>s.trim()).filter(s=>s && !s.startsWith('#'));
    if(lines.length < 9) return alert('Please paste 9 rows (use . for blanks) or full .sdk content.');
    const grid = lines.slice(0,9).map(row=>{
      const r = row.replace(/[^0-9.]/g,'.').padEnd(9,'.').slice(0,9);
      return Array.from(r).map(ch => ch === '.' ? 0 : parseInt(ch,10));
    });
    // clear cell notes
    cells.forEach(c=>{ c.candidatesSet.clear(); });
    cachedSolution = null;
    for(let r=0;r<9;r++) for(let c=0;c<9;c++){
      const v = grid[r][c] || '';
      const idx = r*9+c;
      cells[idx].inp.value = v ? String(v) : '';
      cells[idx].div.classList.toggle('clue', !!v);
      cells[idx].inp.readOnly = !!v;
    }
    refreshAll();
    resetTimer();
    startTimer();
    updateBest();
  });

  exportBtn.addEventListener('click', ()=>{
    const g = grid2d();
    const text = g.map(r => r.map(v=>v||'.').join('')).join('\n');
    if(navigator.clipboard && navigator.clipboard.writeText) navigator.clipboard.writeText(text).then(()=>alert('Copied to clipboard'));
    else prompt('Copy puzzle (.sdk):', text);
  });

  clearBtn.addEventListener('click', ()=>{
    cells.forEach(c=>{
      c.inp.value = '';
      c.div.classList.remove('clue','conflict','match');
      c.candidatesSet.clear();
      c.inp.readOnly = false;
    });
    cachedSolution = null;
    currentlyHighlightedVal = null;
    refreshAll();
    resetTimer();
    updateBest();
  });

  pencilToggle.addEventListener('click', ()=>{
    pencilMode = !pencilMode;
    pencilToggle.textContent = 'Pencil Mode: ' + (pencilMode ? 'ON' : 'OFF');
    cells.forEach(c => c.div.classList.toggle('pencil-mode', pencilMode));
    refreshAll();
  });

  autoCandsBtn.addEventListener('click', ()=>{
    autoCandidates = !autoCandidates;
    autoCandsBtn.textContent = 'Auto Candidates: ' + (autoCandidates ? 'ON' : 'OFF');
    refreshAll();
  });

  solveBtn.addEventListener('click', ()=>{
    const sol = cachedSolution || computeSolution();
    if(!sol) return alert('No solution / puzzle invalid');
    // apply solution
    for(let r=0;r<9;r++) for(let c=0;c<9;c++){
      const idx = r*9+c;
      cells[idx].inp.value = String(sol[r][c]);
      cells[idx].div.classList.remove('clue');
      cells[idx].inp.readOnly = false;
      cells[idx].candidatesSet.clear();
    }
    cachedSolution = sol;
    refreshAll();
    solvedActions();
  });

  hintBtn.addEventListener('click', ()=>{
    if(!cachedSolution) cachedSolution = computeSolution();
    if(!cachedSolution) return alert('No solution available (puzzle invalid)');
    const g = grid2d();
    for(let r=0;r<9;r++) for(let c=0;c<9;c++){
      if(g[r][c] === 0){
        const idx = r*9 + c;
        cells[idx].inp.value = String(cachedSolution[r][c]);
        cells[idx].div.classList.add('correct-pulse');
        setTimeout(()=>cells[idx].div.classList.remove('correct-pulse'), 900);
        refreshAll();
        checkConflicts();
        if(isSolvedAndValid()) solvedActions();
        return;
      }
    }
    alert('No empty cells');
  });

  checkBtn.addEventListener('click', ()=> {
    const ok = checkConflicts();
    alert(ok ? 'No conflicts found.' : 'Conflicts highlighted in red.');
  });

  /* initial state */
  cells.forEach(c => { if(!c.candidatesSet) c.candidatesSet = new Set(); });
  refreshAll();
  updateBest();

  /* utility re-export for some closures */
  function refreshAll(){ for(const cell of cells) refreshCandidatesForCell(cell); checkConflicts(); }
})();
</script>
</body>
</html>
