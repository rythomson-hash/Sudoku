<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Sudoku Player â€” Enhanced</title>
<meta name="theme-color" content="#0b1220"/>
<style>
  :root{
    --bg:#f6f8fb; --card:#ffffff; --muted:#6b7280; --accent:#0b84ff;
    --cell-bg:#fff; --cell-border:#d1d5db; --thick:#111827;
    --match:#fffbcc; --correct:#d1ffd8; --wrong:#ffd6d6;
  }
  [data-theme="dark"]{
    --bg:#07101a; --card:#08121a; --muted:#9aa4b2; --accent:#4aa8ff;
    --cell-bg:#07101a; --cell-border:#16222b; --thick:#e6eef8;
    --match:#2b3a2a; --correct:#123017; --wrong:#501212;
  }

  html,body{height:100%;margin:0;background:linear-gradient(180deg,var(--bg),#e9eef8);font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,Helvetica,Arial; -webkit-font-smoothing:antialiased;color:var(--thick);}
  .wrap{max-width:820px;margin:18px auto;padding:16px;display:flex;flex-direction:column;gap:12px;}
  header{display:flex;align-items:center;gap:12px;}
  header h1{margin:0;font-size:18px;}
  header .meta{margin-left:auto;color:var(--muted);font-size:13px;}
  .card{background:var(--card);border-radius:12px;padding:12px;box-shadow:0 6px 18px rgba(12,22,39,0.06);border:1px solid rgba(15,23,42,0.04);}
  .controls{display:flex;gap:8px;flex-wrap:wrap;align-items:center;}
  textarea{width:100%;min-height:86px;padding:10px;border-radius:8px;border:1px solid var(--cell-border);resize:vertical;background:transparent;color:inherit}
  .btn{padding:10px 12px;border-radius:10px;border:0;background:var(--accent);color:white;font-weight:600;font-size:14px;cursor:pointer;box-shadow:0 6px 14px rgba(11,132,255,0.12)}
  .btn.ghost{background:transparent;color:var(--muted);box-shadow:none;border:1px solid var(--cell-border)}
  .row{display:flex;gap:8px;align-items:center;}
  .board-wrap{display:flex;gap:16px;flex-direction:row;flex-wrap:wrap;align-items:flex-start;justify-content:center}
  .board{display:grid;grid-template-columns:repeat(9,calc(100vmin/11));gap:4px;background:transparent;touch-action:manipulation;}
  .cell{width:calc(100vmin/11);height:calc(100vmin/11);display:flex;align-items:center;justify-content:center;border-radius:8px;background:var(--cell-bg);border:1px solid var(--cell-border);box-shadow:0 1px 0 rgba(0,0,0,0.02) inset;transition:transform .12s ease, box-shadow .12s ease, background-color .18s ease;}
  .cell input{width:100%;height:100%;border:0;background:transparent;font-size:20px;text-align:center;font-weight:700;outline:none;color:var(--thick);cursor:default;}
  .cell input:focus{outline:none;}

  @media(min-width:420px){ .board {grid-template-columns:repeat(9,48px);} .cell{width:48px;height:48px;} .cell input{font-size:20px;} }

  /* 3x3 box thick borders */
  .cell.box-right{border-right:3px solid var(--thick);}
  .cell.box-bottom{border-bottom:3px solid var(--thick);}

  .clue input{font-weight:900;color:var(--thick);}
  .selected{box-shadow:0 6px 20px rgba(11,132,255,0.14);transform:translateY(-2px);}
  .match{background:var(--match);}
  .correct-pulse{animation:correct-pulse .8s ease forwards;}
  @keyframes correct-pulse{0%{background:var(--correct);transform:scale(1.02);}50%{transform:scale(1.03);}100%{transform:none;background:transparent;}}

  .red-flash{animation:red-flash .8s ease forwards;}
  @keyframes red-flash{0%{background:var(--wrong);transform:translateY(-2px);}60%{transform:translateY(0);}100%{background:transparent;}}

  /* subtle glow on select */
  .glow{transition:box-shadow .25s ease;box-shadow:0 0 18px rgba(11,132,255,0.16);}

  .footer{font-size:13px;color:var(--muted);margin-top:8px}
  .actions{display:flex;gap:8px;flex-wrap:wrap;}
  .top-row{display:flex;gap:8px;align-items:center;}
  .toggle{margin-left:auto;padding:8px;border-radius:8px;border:1px solid var(--cell-border);cursor:pointer;background:transparent}
  .hintBtn{background:linear-gradient(180deg,#ffb86b,#ff8f3b);box-shadow:0 6px 14px rgba(255,140,60,0.18)}
  .center{display:flex;justify-content:center;align-items:center}
  /* confetti canvas overlay */
  #confettiCanvas{position:fixed;left:0;top:0;pointer-events:none;width:100%;height:100%;z-index:9999;}
  .small{font-size:12px;padding:8px 10px}
</style>
</head>
<body>
<canvas id="confettiCanvas"></canvas>
<div class="wrap" id="wrap">
  <header>
    <h1>Sudoku Player</h1>
    <div class="meta">Hints â€¢ Animations â€¢ Confetti</div>
  </header>

  <div class="card">
    <div class="top-row">
      <div style="flex:1">
        <textarea id="raw" placeholder="Paste .sdk content or 9 rows (use '.' for blanks)."></textarea>
      </div>
      <div style="display:flex;flex-direction:column;gap:8px;margin-left:8px">
        <button id="parseBtn" class="btn small">Parse & Load</button>
        <button id="hintBtn" class="btn hintBtn small">Hint (1 cell)</button>
        <button id="solveBtn" class="btn small">Auto-solve</button>
        <button id="checkBtn" class="btn ghost small">Check</button>
        <button id="exportBtn" class="btn ghost small">Export .sdk</button>
      </div>
    </div>

    <div style="height:12px"></div>

    <div class="board-wrap center">
      <div id="board" class="board" aria-label="Sudoku board"></div>
    </div>

    <div class="footer">
      <div style="display:flex;gap:12px;align-items:center">
        <div class="hint">Tap a cell to type. Use Hint for one-cell help. When you finish the puzzle you'll get confetti ðŸŽ‰</div>
        <button id="clearBtn" class="btn ghost small" style="margin-left:auto">Clear</button>
        <button id="theme" class="toggle small">Toggle Dark</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const board = document.getElementById('board');
  const raw = document.getElementById('raw');
  const confettiCanvas = document.getElementById('confettiCanvas');
  const ctx = confettiCanvas.getContext && confettiCanvas.getContext('2d');
  let particles = [];
  let confettiAnimating = false;

  function resizeCanvas(){
    confettiCanvas.width = window.innerWidth;
    confettiCanvas.height = window.innerHeight;
  }
  window.addEventListener('resize', resizeCanvas);
  resizeCanvas();

  // create grid
  const cells = [];
  for(let r=0;r<9;r++){
    for(let c=0;c<9;c++){
      const div = document.createElement('div');
      div.className = 'cell';
      if((c+1)%3===0 && c!==8) div.classList.add('box-right');
      if((r+1)%3===0 && r!==8) div.classList.add('box-bottom');
      const inp = document.createElement('input');
      inp.type='tel'; inp.inputMode='numeric'; inp.maxLength=1; inp.autocomplete='off';
      inp.addEventListener('input', (e)=>{ e.target.value = e.target.value.replace(/[^1-9]/g,''); onCellInput(e.target); });
      inp.addEventListener('focus', (e)=> onCellFocus(e.target));
      inp.addEventListener('blur', (e)=> onCellBlur(e.target));
      inp.addEventListener('keydown', (e)=>{ if(e.key==='Backspace' || e.key==='Delete'){ e.target.value=''; } });
      div.appendChild(inp);
      board.appendChild(div);
      cells.push({div,inp,r,c});
    }
  }

  function onCellInput(target){
    // brief pulse for correct placement if matches solution
    // we'll check after user uses check or hint
  }

  function onCellFocus(target){
    clearHighlights();
    const val = target.value.trim();
    // highlight selected cell
    const parent = target.parentElement;
    parent.classList.add('selected','glow');
    // highlight matches
    if(val){
      for(let i=0;i<cells.length;i++){
        if(cells[i].inp.value.trim() === val){
          cells[i].div.classList.add('match');
        }
      }
    }
  }

  function onCellBlur(target){
    // remove selected/glow after small delay so taps still show effect
    const parent = target.parentElement;
    parent.classList.remove('selected','glow');
    // keep matches until the next focus event for clarity
    setTimeout(()=> clearHighlights(), 350);
  }

  function clearHighlights(){
    cells.forEach(c=>{ c.div.classList.remove('match'); });
  }

  function setGrid(grid, clues=false){
    for(let r=0;r<9;r++) for(let c=0;c<9;c++){
      const i = r*9+c;
      const v = (grid[r] && grid[r][c]) ? String(grid[r][c]) : '';
      cells[i].inp.value = v;
      if(clues && v){
        cells[i].div.classList.add('clue');
        cells[i].inp.readOnly = true;
      } else {
        cells[i].div.classList.remove('clue');
        cells[i].inp.readOnly = false;
      }
    }
  }

  function getGrid(){
    const g = Array.from({length:9},()=>Array(9).fill(0));
    for(let i=0;i<81;i++){
      const r=Math.floor(i/9), c=i%9;
      const v = cells[i].inp.value.trim();
      g[r][c] = v===''?0:parseInt(v,10);
    }
    return g;
  }

  // parser accepts .sdk with comments, 9 rows, or an 81-character compact string
  function parseText(txt){
    if(!txt) return null;
    const lines = txt.split(/\r?\n/).map(s=>s.trim()).filter(s=>s!=='' && !s.startsWith('#'));
    if(lines.length>=9){
      const rows=[];
      for(let i=0;i<9;i++){
        const l = lines[i] || '';
        const filtered = l.replace(/[^0-9.]/g,'.');
        const row = [];
        for(let ch of filtered){
          if(ch==='.') row.push(0);
          else row.push(parseInt(ch,10));
          if(row.length===9) break;
        }
        while(row.length<9) row.push(0);
        rows.push(row);
      }
      return rows;
    }
    const compact = txt.replace(/[^0-9.]/g,'');
    if(compact.length>=81){
      const rows=[];
      const s = compact.slice(0,81);
      for(let r=0;r<9;r++){
        rows.push(Array.from(s.slice(r*9,(r+1)*9)).map(ch=> ch==='.'?0:parseInt(ch,10)));
      }
      return rows;
    }
    return null;
  }

  // solver (backtracking)
  function isValid(grid,r,c,val){
    for(let i=0;i<9;i++){ if(grid[r][i]===val) return false; if(grid[i][c]===val) return false; }
    const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
    for(let i=0;i<3;i++) for(let j=0;j<3;j++) if(grid[br+i][bc+j]===val) return false;
    return true;
  }
  function findEmpty(grid){
    for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(grid[r][c]===0) return [r,c];
    return null;
  }
  function solveGrid(grid){
    const empty = findEmpty(grid);
    if(!empty) return true;
    const [r,c]=empty;
    for(let v=1; v<=9; v++){
      if(isValid(grid,r,c,v)){
        grid[r][c]=v;
        if(solveGrid(grid)) return true;
        grid[r][c]=0;
      }
    }
    return false;
  }

  // find conflicts (duplicates in row/col/box)
  function findConflicts(g){
    const list=[];
    for(let r=0;r<9;r++){
      for(let c=0;c<9;c++){
        const v=g[r][c];
        if(!v) continue;
        for(let k=0;k<9;k++){
          if(k!==c && g[r][k]===v) list.push([r,c]);
          if(k!==r && g[k][c]===v) list.push([r,c]);
        }
        const br=Math.floor(r/3)*3, bc=Math.floor(c/3)*3;
        for(let i=0;i<3;i++) for(let j=0;j<3;j++){
          const rr=br+i, cc=bc+j;
          if((rr!==r || cc!==c) && g[rr][cc]===v) list.push([r,c]);
        }
      }
    }
    const seen={};
    return list.filter(([r,c])=>{ const k=r+','+c; if(seen[k]) return false; seen[k]=1; return true; });
  }

  // UI buttons
  document.getElementById('parseBtn').addEventListener('click', ()=>{
    const grid = parseText(raw.value);
    if(!grid){ alert('Could not parse â€” paste the 9 rows or the .sdk content.'); return; }
    setGrid(grid,true);
    // clear old solution cache
    cachedSolution = null;
  });

  document.getElementById('clearBtn').addEventListener('click', ()=>{
    setGrid(Array.from({length:9}, ()=>Array(9).fill(0)), false);
    cachedSolution = null;
  });

  document.getElementById('exportBtn').addEventListener('click', ()=>{
    const g = getGrid();
    let out = '#Exported from Sudoku Player\\n';
    for(let r=0;r<9;r++) out += g[r].map(v=> v?String(v):'.').join('') + '\\n';
    const b = new Blob([out], {type:'text/plain'});
    const url = URL.createObjectURL(b);
    const a = document.createElement('a'); a.href=url; a.download='puzzle.sdk'; a.click(); URL.revokeObjectURL(url);
  });

  // compute and memoize solution for current clues (to speed hints/checks)
  let cachedSolution = null;
  function computeSolution(){
    const g = getGrid();
    const copy = g.map(r=>r.slice());
    if(!solveGrid(copy)) return null;
    return copy;
  }

  // Hint: fill a single cell (smart: choose empty cell with fewest candidates)
  document.getElementById('hintBtn').addEventListener('click', ()=>{
    // compute solution if not cached
    if(!cachedSolution) cachedSolution = computeSolution();
    if(!cachedSolution){ alert('No solution could be found for this puzzle (it may be invalid).'); return; }

    // find empty cells
    const g = getGrid();
    const empties = [];
    for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(g[r][c]===0) empties.push([r,c]);
    if(empties.length===0){ alert('No empty cells â€” puzzle is already filled.'); return; }

    // choose a "good" empty: fewest candidates by checking isValid
    let best = null, bestCount = 99;
    for(const [r,c] of empties){
      let cnt = 0;
      for(let v=1; v<=9; v++) if(isValid(g,r,c,v)) cnt++;
      if(cnt < bestCount){ bestCount = cnt; best = [r,c]; }
    }
    const [rr,cc] = best || empties[0];
    const i = rr*9 + cc;
    const value = cachedSolution[rr][cc];
    // set and animate the cell
    cells[i].inp.value = String(value);
    cells[i].div.classList.add('correct-pulse');
    // after animation remove class
    setTimeout(()=> cells[i].div.classList.remove('correct-pulse'), 900);
    // recompute solution cache to allow further hints
    cachedSolution = computeSolution();
    // check if finished
    setTimeout(()=>{ if(isSolvedAndValid()) launchConfetti(); }, 500);
  });

  document.getElementById('solveBtn').addEventListener('click', ()=>{
    let sol = cachedSolution || computeSolution();
    if(!sol){ alert('No solution found for current grid.'); return; }
    if(!confirm('Fill the entire grid with the solver answer?')) return;
    setGrid(sol,false);
    cachedSolution = sol;
    setTimeout(()=> launchConfetti(), 300);
  });

  // Check: compare current entries to solved grid; mark wrong cells with red flash
  document.getElementById('checkBtn').addEventListener('click', ()=>{
    const sol = cachedSolution || computeSolution();
    if(!sol){ alert('Cannot check: puzzle has no single valid solution or is invalid.'); return; }
    const g = getGrid();
    const wrong = [];
    for(let r=0;r<9;r++) for(let c=0;c<9;c++){
      if(g[r][c]!==0 && g[r][c] !== sol[r][c]) wrong.push([r,c]);
    }
    if(wrong.length===0){
      alert('All entered digits match the solver (so far).');
      if(isSolvedAndValid()) launchConfetti();
      return;
    }
    // flash wrong cells
    for(const [r,c] of wrong){
      const idx = r*9+c;
      const d = cells[idx].div;
      d.classList.add('red-flash');
      setTimeout(()=> d.classList.remove('red-flash'), 900);
    }
  });

  // is puzzle fully filled and matches solution
  function isSolvedAndValid(){
    const sol = cachedSolution || computeSolution();
    if(!sol) return false;
    const g = getGrid();
    for(let r=0;r<9;r++) for(let c=0;c<9;c++) if(g[r][c] !== sol[r][c]) return false;
    return true;
  }

  // highlight matching numbers when a cell with a digit is tapped
  board.addEventListener('click', (ev)=>{
    const tgt = ev.target;
    if(tgt.tagName !== 'INPUT') return;
    // focus will handle highlights
  });

  // small theme toggle
  const themeBtn = document.getElementById('theme');
  function setTheme(t){
    document.documentElement.setAttribute('data-theme', t);
    themeBtn.textContent = t==='dark' ? 'Light' : 'Dark';
  }
  const prefersDark = window.matchMedia && window.matchMedia('(prefers-color-scheme: dark)').matches;
  setTheme(prefersDark ? 'dark' : 'light');
  themeBtn.addEventListener('click', ()=>{
    const cur = document.documentElement.getAttribute('data-theme') === 'dark' ? 'dark' : 'light';
    setTheme(cur === 'dark' ? 'light' : 'dark');
  });

  // confetti implementation (lightweight)
  function rand(min,max){ return Math.random()*(max-min)+min; }
  function launchConfetti(){
    if(!ctx) return;
    if(confettiAnimating) return;
    confettiAnimating = true;
    const w = confettiCanvas.width, h = confettiCanvas.height;
    particles = [];
    const colors = ['#FF6B6B','#FFD93D','#6BCB77','#4D96FF','#C084FC'];
    const count = Math.min(100, Math.floor((w*h)/50000)); // scale by screen
    for(let i=0;i<count;i++){
      particles.push({
        x: rand(0,w), y: rand(-h*0.5,0),
        vx: rand(-2,2), vy: rand(2,6),
        size: rand(6,12), rot: rand(0,360), color: colors[Math.floor(Math.random()*colors.length)],
        life: rand(60,110)
      });
    }
    let tick = 0;
    function step(){
      tick++;
      ctx.clearRect(0,0,w,h);
      for(let p of particles){
        p.x += p.vx; p.y += p.vy; p.vy += 0.06; p.rot += 6;
        p.life--;
        ctx.save();
        ctx.translate(p.x,p.y);
        ctx.rotate((p.rot*Math.PI)/180);
        ctx.fillStyle = p.color;
        ctx.fillRect(-p.size/2, -p.size/2, p.size, p.size*0.6);
        ctx.restore();
      }
      particles = particles.filter(p=>p.life>0 && p.y < h+50);
      if(particles.length>0) requestAnimationFrame(step);
      else { confettiAnimating=false; ctx.clearRect(0,0,w,h); }
    }
    step();
  }

  // initial empty board
  setGrid(Array.from({length:9}, ()=>Array(9).fill(0)), false);

  // small UX: when clicking a cell, show matching highlights immediately
  for(const c of cells){
    c.inp.addEventListener('focus', ()=>{
      const val = c.inp.value.trim();
      // clear previous
      cells.forEach(x=> x.div.classList.remove('match','selected','glow'));
      c.div.classList.add('selected','glow');
      if(val){
        for(const o of cells) if(o.inp.value.trim() === val) o.div.classList.add('match');
      }
    });
    c.inp.addEventListener('input', ()=>{
      // update matches on input
      const v = c.inp.value.trim();
      cells.forEach(x=> x.div.classList.remove('match'));
      if(v){
        for(const o of cells) if(o.inp.value.trim() === v) o.div.classList.add('match');
      }
    });
    c.inp.addEventListener('blur', ()=>{
      setTimeout(()=> cells.forEach(x=> x.div.classList.remove('selected','glow')), 200);
    });
  }

  // expose a small helper to load a sample quickly (for debugging)
  window.__loadSample = function(){
    const sample = [
      [2,0,0,0,0,0,0,0,0],
      [9,0,0,0,0,0,1,8,0],
      [8,0,7,0,4,3,0,6,5],
      [0,0,6,5,0,0,0,0,4],
      [0,0,0,0,0,0,0,6,0],
      [0,9,0,0,7,0,0,0,1],
      [0,0,0,8,3,0,0,0,0],
      [0,4,0,0,6,5,0,0,0],
      [0,5,0,2,0,0,0,7,0],
    ];
    setGrid(sample,true);
  };
})();

function setGrid(){ /* placeholder to satisfy some browsers if script splitting occurs */ }
</script>
</body>
</html>
